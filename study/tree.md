트리
===

# 트리

트리(`tree`)는 노드와 에지로 연결된 특수한 형태이다.

## 트리의 특징

- 순환 구조(`cycle`)를 지니고 있지 않고, 1개의 루트 노드가 존재한다.
- 루트 노드를 제외한 노드는 단 1개의 부모 노드를 갖는다.
- 트리의 부분 트리(`subtree`)역시 트리의 모든 특징을 따른다.

## 트리의 핵심 이론

### 구성 요소

- 노드 : 데이터의 index 와 value 를 표현하는 요소
- 에지 : 노드와 노드의 연결 관계를 나타내는 ㄴ
- 루트 노드 : 트리에서 가장 상위에 존재하는 노드
- 부모 노드 : 두 노드 사이의 관계에서 상위 노드에 해당하는 노드
- 자식 노드 : 두 노드 사이의 관계에서 하위 노드에 해당하는 노드
- 리프 노드 : 트리에서 가장 하위에 존재하는 노드 (자식 노드가 없는 노드)
- 서브 트리 : 전체 트리에 속한 작은 트리

# 트라이

트라이(`trie`)는 문자열 검색을 빠르게 실행할 수 있도록 설계한 트리 형태의 자료구조이다.

## 트라이의 특징

- N진 트리: 문자 종류의 개수에 따라 N이 결정된다. 예를 들어 알파벳은 26개의 문자로 이뤄져 있으므로 26진 트리로 구성된다.
- 루트 노드는 항상 빈 문자열을 뜻하는 공백 상태를 유지한다.

## 트라이의 핵심 이론

트라이는 일반적으로 단어들을 사전의 형태로 생성한 후 트리의 부모 자식 노드 관계를 이용해 검색을 수행한다.

# 이진 트리

이진 트리(`binary tree`)는 각 노드의 자식 노드(차수)의 개수가 2 이하로 구성돼 있는 트리를 맣한다.

## 이진 트리의 핵심 이론

### 이진 트리의 종류

- 편향 이진 트리 : 노드들이 한쪽으로 편향돼 생성된 이진 트리이며, 공간이 많이 낭비되고 탐색 속도가 저하된다.
- 포화 이진 트리 : 트리의 높이가 모두 일정하며 리프 노드가 꽉찬 이진 트리 이다.
- 완전 이진 트리 : 마지막 레벨을 제외하고 완전하게 노드들이 채워져 있고, 마지막 레벨은 왼쪽부터 채워진 트리이다.

일반적으로 코딩 테스트에서 데이터를 트리에 담는다고 하면 완전 이진 트리 형태를 떠올리면 된다.

### 이진 트리의 순차 표현

가장 직관적이면서 편리한 트리 자료구조 형태는 바로 `배열`이다.

이진 트리는 1차원 배열의 형태로 표현할 수 있고, 1차원 배열의 형태로 표현할 때  
트리의 노드와 배열의 인덱스 간의 상관 관계는 다음과 같다

| 이동 목표 노드  |         인덱스 연산          |   제약 조건(N = 노드 개수)   |
|:---------:|:-----------------------:|:--------------------:|
|   루트 노드   |       `index = 1`       |                      |
|   부모 노드   |   `index = index / 2`   |   현재 노드가 루트 노드가 아님   |
| 왼쪽 자식 노드  |   `index = index * 2`   |   `index * 2 <= N`   |
| 오른쪽 자식 노드 | `index = index * 2 + 1` | `index * 2 + 1 <= N` |

위의 표에서 보이는 인덱스 연산 방식은 향후 세그먼트 트리(`segment tree`) 나 LCA(`lowest common ancestor`)  
알고리즘에서도 기본이 되는 연산이다.

# 세그먼트 트리

세그먼트 트리는 주어진 데이터들의 구간 합과 데이터 업데이트를 빠르게 수행하기 위해 고안해낸 자료구조이다.  
더 큰 범위는 인덱스 트리 라고 불리는데, 코딩 테스트 영역에서는 큰 차이가 없다고 생각해도 된다.

## 세그먼트 트리 핵심 이론

세그먼트 트리의 종류는 구간 합, 최대 / 최소 구하기로 나눌 수 있고,  
구현 단계는 트리 초기화하기, 질의값 구하기(구간 합 또는 최대/최소), 데이터 업데이트하기로 나눌 수 있다.

### 1. 트리 초기화하기

리프 노드의 개수가 데이터의 개수(N) 이상이 되도록 트리 배열을 만든다.  
트리 배열의 크기를 구하는 방법은 `2^k >= N` 을 만족하는 k의 최솟값을 구한 후 `2^k * k` 를 트리 배열의 크기로 정의하면 된다.

```
샘플 데이터 가 다음과 같을 때
{5, 8, 4, 3, 7, 2, 1, 6}

N = 8 이고,
2^3 >= 8 이기 때문에,
k = 3 이다.
2^3 * 3 = 16 이므로,
배열의 크기를 16으로 정의한다.
```

리프 노드에 원본 데이터를 입력하고, 각 리프 노드의 부모 노드에 해당 자식 노드 들의 각 케이스별 결과 값을 적어 넣는다.  
자식 노드의 인덱스는 이진 트리 형식이기 때문에 2N, 2N + 1 이 된다.  

```
구간 합
0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15
  36 20 16 13  7  9  7  5  8   4   3   7   2   1   6
```

```
최대
0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15
   8  8  7  8  4  7  6  5  8   4   3   7   2   1   6
```

```
최소
0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15
   1  3  1  5  3  2  1  5  8   4   3   7   2   1   6
```

### 2. 질의값 구하기

주어진 질의 인덱스를 세그먼트 트리의 리프 노드에 해당하는 인덱스로 변경한다.  
기존 샘플을 기준으로 한 인덱스값과 세그먼트 트리 배열에서의 인덱스 값이 다르기 때문에 인덱스를 변경해야 한다.

#### 질의 인덱스를 세그먼트 트리 인덱스로 변경하는 방법

세그먼트 트리 index = 주어질 질의 index + 2^k - 1

#### 질의값 구하는 과정

1. startIndex % 2 == 1 일 때 해당 노드를 선택한다.
2. endIndex % 2 == 0 일 때 해당 노드를 선택한다.
3. 1 ~ 2 에서 노드를 선택하지 않았다면 startIndex = (startIndex + 1) / 2 연산을 실행한다.
4. 1 ~ 2 에서 노드를 선택하지 않았다면 endIndex = (endIndex - 1) / 2 연산을 실행한다.
5. 1 ~ 4 에서 반복하다가 endIndex < startIndex 가 되면 종료한다.

#### 질의에 해당하는 노드 선택 방법

- 구간 합 : 선택된 노드들을 모두 더한다.
- 최댓값 구하기 : 선택된 노드들 중 MAX 값을 선택해 출력한다.
- 최솟값 구하기 : 선택된 노드들 중 MIN 값을 선택해 출력한다.

### 3. 데이터 업데이트하기

업데이트 방식은 자신의 부모 노드로 이동하면서 업데이트한다는 것은 동일하지만, 어떤 값으로 업데이트 할 것인지에 관해서는 트리 타입별로 다르다.

구간 합에서는 원래 데이터와 변경 데이터의 차이만큼 부모 노드로 올라가면서 변경하고,  

최댓값 찾기에서는 변경 데이터와 자신과 같은 부모를 지니고 있는 다른 자식 노드와 비교해 더 큰 값으로 업데이트한 뒤  
업데이트가 일어나지 않으면 종료한다.  

마지막으로 최솟값 찾기에서는 변경 데이터와 자신과 같은 부모를 지니고 있는 다른 자식 노드와 비교해 더 작은 값으로 업데이트한 뒤  
업데이트가 일어나지 않으면 종료한다.

# 최소 공통 조상

트리 그래프에서 임의의 두 노드를 선택했을 때 두 노드가 각각 자신을 포함해 거슬러 올라가면서 부모 노드를 탐색할 때 처음 공통으로 만나게 되는  
부모 노드를 최소 공통 조상(`LCA: lowest common ancestor`)이라고 한다.

## 최소 공통 조상 핵심 이론

### 일반적인 최소 공통 조상 구하기

선택된 두 노드의 깊이가 다른 경우, 더 깊은 노드의 노드를 부모 노드로 1개씩 올려주면서 같은 깊이로 맞춘다.  
이때 두 노드가 같으면 해당 노드가 최소 공통 조상 이므로 탐색을 종료한다.

깊이가 같은 상태에서는 동시에 부모 노드로 올라가면서 두 노드가 같은 노드가 될 때까지 반복한다.  
이때 처음 만나는 노드가 최소 공통 조상이 된다.

## 최소 공통 조상 빠르게 구하기

최소 공통 조상 빠르게 구하기의 핵심은 서로의 깉이를 맞춰 주거나 같아지는 노드를 찾을 때 기존에 한 단계씩 올려 주는 방식에서  
2^k 씩 올라가 비교하는 방식이다.  
따라서 기존에 자신의 부모 노드만 저장해 놓던 방식에서 2^k 번째 위치의 부모 노드까지 저장해 둬야 한다.

### 1. 부모 노드 저장 배열 만들기

```
부모 노드 배열의 정의
P[K][N] = N번 노드의 2^K 번째 부모의 노드 번호

부모 노드 배열의 점화식
P[K][N] = P[K - 1][P[K - 1][N]]
```

### 2. 선택된 두 노드의 깊이 맞추기

P 배열을 이용해 기존에 한 단계씩 맞췄던 깊이를 2K 단위로 넘어가면서 맞춘다.

### 3. 최소 공통 조상 찾기

공통 조상을 찾는 작업 역시 한 단계씩이 아닌 2K 단위로 점프하면서 맞춘다.  
P 배열을 이용해 최초로 두 노드의 부모가 같아지는 값을 찾고,  
최초로 같아지는 K 값보다 1개 작은 곳으로 이동한다.  
이를 반복해 진행하면서 K = 0 , K = 1 일 때 같은 값이 나오면 알고리즘이 종료되고 해당 값이 최소 공통 부모의 값이 된다.

