정수론
===

# 소수 구하기

소수 (`prime number`)는 자신보다 작은 2개의 자연수를 곱해 만들 수 없는 1보다 큰 자연수를 말한다.  
같은 의미로 1과 자기 자신 외에 약수가 존재하지 않는 수를 말한다.

## 소수 구하기 핵심 이론

### 에라토스테네스의 체 원리

1. 구하고자 하는 소수의 범위만큼 1차원 배열을 생성한다.
2. 2부터 시작하고 현재 숫자가 지워지지 않을 때는 현재 선택된 숫자의 배수에 해당하는 수를 배열에서 끝까지 탐색하면서 지운다.  
    이때 처음으로 선택된 숫자는 지우지 않는다.
3. 배열의 끝까지 2를 반복한 후 배열에서 남아 있는 모든 수를 출력한다.

## 오일러 피

오일러 피 함수 P[N] 의 정의는 1부터 N까지 범위에서 N과 서로소인 자연수의 개수를 뜻한다.  
오일러 피 함수는 증명 과정을 공부해야 완벽하게 알 수 있지만, 여기서는 구현 부분만 알아본다.

### 오일러 피의 핵심 이론

1. 구하고자 하는 오일러 피의 범위만큼 배열을 초기화한다.
2. 2부터 시작해 현재 배열의 값과 인덱스가 같으면(= 소수일 때) 현재 선택된 숫자(K)의 배수에 해당하는 수를  
    배열에 끝까지 탐색하면 `P[i] = P[i] - P[i]/K` 연산을 수행한다.(i는 K의 배수)
3. 배열의 끝까지 2를 반복하여 오일러 피 함수를 완성한다.

## 유클리드 호제법

유클리드 호제법 (`euclidean-algorithm`)은 두 수의 최대 공약수를 구하는 알고리즘이다.  
일반적으로 최대 공약수를 구하는 방법은 소인수분해를 이용한 공통된 소수들의 곱으로 표현할 수 있지만,  
유클리드 호제법은 좀 더 간단한 방법을 제시한다.

### 유클리드 호제법 핵심 이론

유클리드 호제법을 수행하려면 먼저 MOD 연산을 이해하고 있어야 한다.

```
MOD => 두 값을 나눈 나머지를 구하는 연산
10 MOD 4 = 2 // 10 % 4 = 2
```

MOD 연산을 이해하면 다음과 같은 3단계로 유클리드 호제법을 구현할 수 있다.

1. 큰 수를 작은 수로 나누는 MOD 연산을 수행한다.
2. 앞 단계에서의 작은 수와 MOD 연산 결괏값(나머지)으로 MOD 연산을 수행한다.
3. 나머지가 0이 되는 순간의 작은 수를 최대 공약수로 선택한다.

## 확장 유클리드 호제법

확장 유클리드 호제법의 목적은 방정식의 해를 구하는 것이다.

### 확장 유클리드 호제법 핵심 이론

```
ax + by = c
(a, b, c, x, y 는 정수)
```

이 때 위의 방정식은 `c % gcd(a, b) = 0` 인 경우에만 정수해를 가진다.  
다시 말해 c 가 a 와 b 의 최대 공약수의 배수인 경우에만 정수해를 가진다.  
이는 `ax + by = c` 가 정수해를 갖게하는 c 의 최솟값이 gcd(a, b) 라는 것을 의미한다.


## `Comparator` VS `Comparable`

자바에서 정렬을 할 때 `primitive type` 의 경우 부등호로 쉽게 대소 비교를 하여 정렬 할 수 있지만,  
객체의 경우 어떤 필드 값을 기준으로 정렬을 할지 모르는 상황이 생긴다.

객체를 비교하고, 정렬 할 수 있게끔 java 에서 제공해주는 두가지 인터페이스가 있는데,  
`Comparator` 와 `Comparable` 이 그것이다.

`Comparator`, `Comparable` 둘 다 인터페이스 이며, 객체의 비교, 정렬을 위해 사용하는 점에 있어서는 비슷하지만,  
비교 하는 대상이 다르다.

`Comparable` 은 `java.lang` 패키지에 있어 `import` 를 할 필요가 없고,  
`Comparator` 는 `java.util` 패키지에 있어 `import` 가 필요하다는 점이 다르다.

`Comparator` 의 경우 `compare(T o1, T o2)` 메서드를 구현해야 하며,  
`Comparable` 의 경우 `compareTo(T o)` 메서드를 구현해야 한다.

즉, `Comparable` 은 자기 자신과 파라미터로 들어오는 객체를 비교하는 것이고,  
`Comparator` 는 자기 자신은 상관없이 파라미터로 들어오는 두 객체를 비교한다는 것이다.

그래서 `Comparable` 은 자기 자신과 비교하기 때문에 클래스에 직접 구현해서 사용하고,  
`Comparator` 는 익명 객체로 생성하여 두 객체를 매개변수로 넣고 사용한다.

`compare(T o1, T o2)`, `compareTo(T o)` 두 메서드 모두 대소 비교를 통해 -1, 0, 1 을 return 하는 것이 아닌  
`a - b` 이런 식으로 대소 비교를 하는 경우 오버플로우를 조심해야 한다.
