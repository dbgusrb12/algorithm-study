정렬
===

정렬은 데이터를 정해진 기준에 따라 배치해 의미 있는 구조로 재설정하는 것을 말한다.

이번에 책에서 배울 정렬 알고리즘은 다음과 같다.

- 버블(bubble): 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식
- 선택(selection): 대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식
- 삽입(insertion): 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식
- 퀵(quick): pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식
- 병합(merge): 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식
- 기수(radix): 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식

# 버블 정렬

버블 정렬(bubble sort)은 두 인접한 데이터의 크기를 비교해 정렬하는 방법이다.  
간단하게 구현 할 순 있지만, 시간 복잡도는 O(n^2)으로 다른 정렬 알고리즘보다 속도가 느린편이다.  

## 버블 정렬 과정

1. 비교 연산이 필요한 루프 벙위를 설정한다.
2. 인접한 데이터 값을 비교한다.
3. swap 조건에 부합하면 swap 연산을 수행한다.
4. 루프 범위가 끝날 때 까지 2 ~ 3 을 반복한다.
5. 정렬 영역을 설정한다. 다음 루프를 실행할 때는 이 영역을 제외한다.
6. 비교 대상이 없을 때 까지 1 ~ 5를 반복한다.

만약 특정한 루프의 전체 영역에서 swap 이 한 번도 발생하지 않았다면  
그 영역 뒤에 있는 데이터가 모두 정렬됐다는 뜻이므로 프로세스를 종료해도 된다.

### 버블 소트 프로그램 문제 핵심 아이디어

- 버블 정렬은 왼쪽에서 오른쪽으로 swap 을 한다.
- 안쪽 루프에서 오른쪽에서 왼쪽으로 swap 되는건 최대 1이다.
- 오른쪽에서 왼쪽으로 swap 된 개수를 구하면 안쪽 루프가 몇번 수행됐는지 알 수 있다.

# 선택 정렬

선택 정렬(selection sort)은 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법이다.  
선택 정렬은 구현 방법이 복잡하고, 시간 복잡도도 O(n^2)으로 효율적이지 않아 코딩 테스트에서는 많이 사용하지 않는다.  

## 선택 정렬 과정

1. 남은 정렬 부분에서 최솟값 또는 최대값을 찾는다.
2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap 한다.
3. 가장 앞에 있는 데이터의 위치를 변경해 (index++) 남은 정렬 부분의 범위를 축소한다.
4. 전체 데이터 크기만큼 index 가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다.

# 삽입 정렬

삽입 정렬(insertion sort)은 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식이다.  
평균 시간 복잡도는 O(n^2) 으로 느린 편이지만 구현하기가 쉽다.

## 삽입 정렬 과정

1. 현재 index 에 있는 데이터 값을 선택한다.
2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색한다.
3. 삽입 위치부터 index 에 있는 위치까지 shift 연산을 수행한다.
4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행한다.
5. 전체 데이터의 크기만큼 index 가 커질 때까지, 즉 선택할 데이터가 없을 때 까지 반복한다.

적절한 삽입 위치를 탐색하는 부분에서 이진 탐색(binary search) 등과 같은 탐색 알고리즘을 사용하면  
시간 복잡도를 줄일 수 있다.

# 퀵 정렬

퀵 정렬(quick sort)은 기준값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 방식이다.  
기준값이 어떻게 선정되는지가 시간 복잡도에 많은 영향을 미치고, 평균적인 시간 복잡도는 O(nlogn)이다.

## 퀵 정렬 과정

`startValue` = `start` 가 가리키는 데이터  
`endValue` = `end` 가 가리키는 데이터  
`pivotValue` = `pivot` 이 가리키는 데이터  

1. 데이터를 분할하는 `pivot` 을 설정한다.
2. `pivot` 을 기준으로 다음 i ~ v 과정을 거쳐 데이터를 2개의 집합으로 분리한다.
   1. `startValue`가 `pivotValue`보다 작으면 `start` 를 오른쪽으로 1칸 이동한다.
   2. `endValue`가 `pivotValue`보다 크면 `end` 를 왼쪽으로 1칸 이동한다.
   3. `startValue`가 `pivotValue`보다 크고, `endValue`가 `pivotValue`보다 작으면  
      `startValue` 와 `endValue` 를 swap 하고 `start` 는 오른쪽, `end` 는 왼쪽으로 1칸씩 이동한다.
   4. `start` 와 `end` 가 만날때까지 `i` ~ `iii` 를 반복한다.
   5. `start` 와 `end` 가 만나면 만난 지점에서 가리키는 데이터와 `pivotValue`를 비교하여  
      `pivotValue`가 크면 만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에 `pivotValue`를 삽입한다.
3. 분리 집합에서 각각 다시 `pivot` 을 선정한다.
4. 분리 집합이 1개 이하가 될 때까지 1 ~ 3 을 반복한다.

`pivot` 으로 선정한 수는 무조건 정렬 순서에 맞게 들어감

# 병합 정렬

병합 정렬(merge sort)은 분할 정복(divide and conquer)방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 방식이다.  
병합 정렬의 시간 복잡도 평균값은 O(nlogn)이다.

## 2개의 그룹을 병합하는 과정

투포인터 개념을 사용하여 왼쪽, 오른쪽 그룹을 병합한다.  
이 때 2개의 그룹은 정렬이 되어있어야 한다.

# 기수 정렬

기수 정렬(radix sort)은 값을 비교하지 않는 특이한 정렬이다.  
값을 놓고 비교할 자릿수를 정한 다음 해당 자릿수만 비교한다.  
기수 정렬의 시간 복잡도는 O(kn) 으로, k는 데이터의 자릿수를 말한다.

## 기수 정렬 수행 방식

기수 정렬을 10개의 큐를 이용하고, 각 큐는 값의 자릿수를 대표한다.  
일의 자릿수 기준으로 배열 원소를 큐에 집어넣고, 0번째 큐부터 9번째 큐까지 pop 을 진행한다.  
그 이후 십의 자릿수를 기준으로 같은 과정을 진행한다.  
마지막 자릿수를 기준으로 정렬할 때까지 앞의 과정을 반복한다.  
